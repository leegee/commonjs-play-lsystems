/*

#define W	.5
#define AS 	 2
#define BS 	 1
#define R 	 1
#define L	-1


 w : !(W)F(BS,R)
p1 : F(s,o) : s == AS && o == R -> F(AS,L)F(BS,R)
p2 : F(s,o) : s == AS && o == L -> F(BS,L)F(AS,R)
p3 : F(s,o) : s == BS	        -> F(AS,o)


!(.5)F(1,1)
!(.5)F(2,1)
!(.5)F(2,-1)F(1,1)
!(.5)F(1,-1)F(2,1)F(2,1)

*/

"use strict";

const RAD = Math.PI / 180.0;
var _invocations = 0;

var LOGGER = log4javascript.getDefaultLogger();
var appender = new log4javascript.BrowserConsoleAppender();
// var popUpLayout = new log4javascript.PatternLayout("%d{HH:mm:ss} %-5p - %m%n");
// appender.setLayout(popUpLayout);
appender.setThreshold(log4javascript.Level.TRACE);
LOGGER.addAppender(appender);			

if (!console){
	console = {};
	console.log = function(){};	
	console.debug = function(){};	
	console.info = function(){};	
}

var Lsys = new Class({
	Implements: [Options],

	xoffset: 	0,
	yoffset: 	0,
	generation:	0,
	total_generations: 0,
	variables:	null,
	interpolateVarsRe: null,
	
	options: { 
		el: null, // destination element
		start		: 'F',
		variables	: '',
		rules		: null,
		merge_duplicates : 1,
		duration 		: 48,
		scale 			: 'pentatonic',
		initial_note_decimal : 58,
		canvas_width		: 2000,
		canvas_height	: 800,
		angle			: 30,
		turtle_step_x	: 10,
		turtle_step_y	: 10,
		init_x			: null,
		init_y			: null,
		line_width		: 1,
		generations_scale_lines: true,
		colours			: [
//			"rgba(244, 0, 0, 0.75)",
//			"rgba(0, 244, 0, 0.75)",
//			"rgba(0, 0, 244, 0.75)",

			"rgba(130, 90, 70, 0.8)",
			"rgba(33, 180, 24, 0.6)", 
			"rgba(50, 210, 50, 0.5)", 
			"rgba(70, 255, 70, 0.4)"
		]
	},
    
	initialize: function( options ){
        Object.keys(options).each( function(i){
        		// Cast string to number
        		if (typeof options[i] === 'string' && options[i].match(/^\s*[.\d+]+\s*$/)) {
				options[i] = parseInt( options[i] );
        		}
        });
        
        this.setOptions(options);
        this.castRules();
        this.castVariables();

		this.interpolateVarsRe = new RegExp( /(\$\w+)/g );

		console.log('Variables: ');
		console.log( this.variables );
		console.log('Rules: ');
		console.log( this.options.rules );

		this.invocations = ++_invocations;
		this.canvas		= new Element('canvas', {
			id: 		'canvas'+this.invocations,
			width: 	this.options.canvas_width,
			height:	this.options.canvas_height
		}).inject( this.options.el, 'top' );
		this.colour		= this.options.colours[0];
		this.content		= '';
		this.x 			= this.options.init_x || 0;
		this.y 			= this.options.init_y || this.options.canvas_height/2;
		this.max_x 		= 0;
		this.max_y 		= 0;
		this.min_x 		= 0;
		this.min_y 		= 0;
		this.ctx			= this.canvas.getContext("2d");
	},
	
	castVariables: function( str ){
		str = str || this.options.variables;
		var rv = {};	
		str.split(/[\n\r\f]+/).each( function(line){
			// Detect 
			var name2val = line.match(/^\s*(#define)?\s*(\$\w+)\s*(\S+)\s*$/);
			// Store
			rv[name2val[2]] = name2val[3];
			// Cast
			if (rv[name2val[2]].match(/^(-+)?\d+(\.\d+)?$/))
				rv[name2val[2]] = parseFloat( rv[name2val[2]] );	
		});
		this.variables = rv;
		return rv;
	},
	
	/* Creates a strucure as follows:
	[ [to_match, condition, substitution ], ...]
	*/
	castRules: function( str ){
		str = str || this.options.rules;
		var rv = [];
		// F(s,o) : s == AS && o == R -> F(AS,L)F(BS,R) \n

		str.split(/[\n\r\f]+/).each( function(line){
			if (line=='') return;
			var head_tail = line.match(
				/^\s*(.+?)\s*->\s*([^\n\r\f]+)\s*/
			);
			var match_condition = head_tail[1].match(
				/([^:]+)\s*:?\s*(.*?)\s*$/	
			);
			var head = match_condition[1].match(/^(.+?)\s*$/);
			var rule = [
				head[1],
				match_condition[2],
				head_tail[2]
			];
			rv.push( rule );
		});
		
		this.options.rules = rv;
		return rv;
	},

	dsin: function(radians){ return Math.sin(radians * RAD) },
	dcos: function(radians){ return Math.cos(radians * RAD) },
	
	generate: function( generations ) {
		console.debug( 'Enter generate for '+generations+' generations');
		this.total_generations = generations;
		this.generation = 0;
		
		if (this.content.length == 0)
			this.content = this.options.start;

		for (this.generation=1; this.generation <= generations; this.generation++){
			this.apply_rules();
		}
		
		this.render();
		this.resize();
		this.finalise();
		console.debug( 'Leave generate -------------------------');
	},

	interploateVars: function( str ){
		var self = this;
		var rv = str.replace( 
			this.interpolateVarsRe,
			function(match){
				return (typeof self.variables[ match ] != 'undefined')?
					self.variables[ match ]
				:	match;
			}
		);
		return rv;
	},
	
	string2re: function( str ){
		var self = this;
		this.str2reRe = new RegExp( /(\w+)\(([^\)]+)\)/	 );
		var rv = str.replace( 
			this.str2reRe,
			function(match, varname, argsCsv){
				var args = argsCsv.split(/\s*,\s*/);
				// Could cache these based on args.length:
				return '('+varname +')\\('+ args.map(function(){
					return '([\\$\\w+]+)'
				}) +'\\)';
			}
		);
		return new RegExp(rv, 'g');
	},
	
	apply_rules: function() {
		var self = this;
		console.debug( 'Enter apply_rules for generation '+this.generation );
		var _new = [];
		
		self.options.rules.each( function( rule ){
			console.log( 'Test for rule '+rule.join(' ')  + ' in content '+self.content	 );
			
			// Re-write the rule to replace variables with literals, where possible:
			var findRe	  		= self.string2re( rule[0] );
			var conditions_str	= self.interploateVars( rule[1] );
			var substitutions	= self.interploateVars( rule[2] );

			// For every part of the content that matches this rule
			// replace 'find' with 'substitutions' if conditions_str
			console.log('Rule says find '+findRe+' in content of '+self.content);
			
			var new_content = self.content.replace(
				findRe,
				function(){
					var varname = arguments[1];
					var rv = varname +'(';
					var args = [];
					for (var i=2; i < arguments.length-2; i++){
						// console.log( 'Find arg '+i+' is var named '+arguments[i]  +' == '+							self.variables[ arguments[i] ] );
						args.push( 
							self.variables[ arguments[i] ]
						);
					}
					rv += args.join(',') + ')';
					return rv;
				}
			);

			console.log('Literal content = '+new_content);
 						
			// console.log('conditions: '+conditions_str);
			// conditions: s == AS && o == R
			var cond_re = new RegExp(
				"\\s*(\\w+)\\s*(\\W+?)\\s*(\\w+)\\s*([<>&=]+)?\\s*",
				"g"
			);
			// console.log('conditions re '+ cond_re );

			var conditions = [];
			var c;
			while ((c = cond_re.exec(conditions_str)) !== null) {
				var cond = {};
				cond[ c[1] ] = {
					operator: c[2],
					operand:  c[3],
					continue_operator: c[4]
				};
				conditions.push(cond);
			}
			
			// console.log( 'Conditions: '+conditions );

			console.log( 'CONTENT: '+self.content );
			
			// Can't accept an array, have to hard-code match-groups:
			var ok = true;
			var new_content = self.content.replace(
				finder_re, 
				function(match, g0, g1, g2, g3, g4, g5, g6, g7, g8){
					console.info('Replace, enter with '+match);
					var rv = '';
					var args = {};
					for (var i=1; i <= find_arg_names_arr.length; i++){
						args[ find_arg_names_arr[i-1] ] = eval('g'+i);	
					}
					console.log('Found args in content, for '+find_varname);
					console.log( args );
				
					// Do the found args match args required by rule conditions?
					// Run through the condition rules:
					var cont = true;
					conditions.each( function(condition){
						// console.log( condition );
						if (!cont)  return;
						Object.keys( condition ).each( function(test_var_name){
							if (!cont) return;
							var v_left = ( args[test_var_name] && args[test_var_name].match(/^[+-]?\d+$/))? 	
								args[test_var_name]
							:	self.variables[args[test_var_name]];
							console.log('Test '+test_var_name+' which holds ' + args[test_var_name]
								+' which is '+v_left
								+' '
								+  condition[test_var_name].operator 
								+ ' '
								+ condition[test_var_name].operand
								+ ' which is '
								+ self.variables[ condition[test_var_name].operand  	]
							);
							var test = '"'+v_left+'"'
								+ ' '+ condition[test_var_name].operator +' '
								+ '"' 
									+ self.variables[ condition[test_var_name].operand ]	
								+ '"';
							ok = eval(test);
							console.log(test +' '+ ok);
							
							// Should processing continue?
							// Cont if this failed but OR condition on next
							// Cont if this passed and AND condition on next
							// Thus
							// No cont if this passed and OR cond on next
							// No cont if this failed and AND cond on next
							if (condition[test_var_name].continue_operator){
								if ( ok && condition[test_var_name].continue_operator == '||' ){
									console.debug('Do not continue...................');
									cont = false;
									return;
								}
								if (ok==false && condition[test_var_name].continue_operator == '&&' ){
									console.debug('Do not continue...................');
									cont = false;
									return;
								}
							}
							console.debug('Continue: ok=='+ok+' and '+ condition[test_var_name].continue_operator+'..................');
						});
					});
				
					// Have conditions been met?
					// Can the substitution be applied?
					console.info( rule[0] +' --> '+ ok);
					
					if (ok){
						console.info('Apply production rule '+rule.join(' ') );
						console.log( "substitutions: >" + substitutions +'<');
						console.log( substitutions );
						// F(AS,L)F(BS,R)
						
						var re = new RegExp(/(\w+)\(([^\)]+?)\)/g);
						console.log( re );
						var subsArgsCsv;
						while ( subsArgsCsv = re.exec( substitutions ) ){
							var varname = subsArgsCsv[1];
							console.log('Right-hand varname: '+varname);
							var subsArgs = subsArgsCsv[2].split(/\s*,\s*/);
							console.log( 'Right-hand, substituion args: '+subsArgs.join(', ') );
							rv += varname+'(';
							
							// Look-up value of subsArgs varialbes
							subsArgs.each( function( a ){
								var v = args[a] || self.variables[a];
								// Literal or variable?
								console.log( 'Substitution args v='+v);
								if (! v.match(/^[+-]?\d+$/)){
									v = args[v] || self.variables[v];
									if (! v.match(/^[+-]?\d+$/)){
										throw('Cannot resolve variable '+v);
										die
									}
								}
								console.info( 'Create RV, '+a +' == '+ v );
								rv += v +',';
							});
							
							rv = rv.substring(0,rv.length-1) + ')';
						} // next group of right-hand args to push to rv
					} // is ok
				
					console.log( rv );
					console.log('_____RV='+rv);
					return rv;
				}
			); // Next replacement of item found in content
			
			if (ok) self.content = new_content;
			console.log('############## '+ok+' ############### Content: '+self.content);
			
		}); // Next rule

		console.log(
			'# FINAL for generation '+this.generation+'/'+this.total_generations+' ############################ Content: '+self.content
		);
	},
	
	render: function(){
		var self = this;
		var dir = 0;
		var states  = [];

		// PRODUCTION_RULES:
		for (var i=0; i < this.content.length; i++){
			var draw = true;
			// console.debug( 'Do '+i);
			switch (this.content.charAt(i).toLowerCase()){
				case 'c':
					self.setColour( parseInt( this.content.charAt( ++i ) ));
					break;
				case '+':
					dir += self.options.angle;
					break;
				case '-':
					dir -= self.options.angle;
					break;
				case '[':
					states.push([dir, self.x, self.y, self.colour]);
					draw = false;
					break;
				case ']':
					var state = states.pop();
					dir = state[0];
					self.x = state[1];
					self.y = state[2];
					self.colour = state[3];
					draw = true;
					break;
			};

			if (draw)
				self.turtle_graph( dir );
		}
		console.info('Leave default_generate_callback');
	},
	
	finalise: function(){
		console.debug( 'Finalised');
	},
		
	turtle_graph: function(dir){
		// console.debug( 'Move '+dir +' from '+this.x+','+this.y );
		
		this.ctx.beginPath();
		/*
		if (this.options.generations_scale_lines){
			this.ctx.lineWidth = this.options.generations	
		}
		else 
		*/
		if (this.options.line_width){
			this.ctx.lineWidth = this.options.line_width
		}
		this.ctx.moveTo( this.x, this.y ); 

		this.x += ( this.dcos(dir) * ( this.options.turtle_step_x ));
		this.y += ( this.dsin(dir) * ( this.options.turtle_step_y ));

		this.x += this.xoffset;
		this.y += this.yoffset;
		
		if (this.x > this.max_x) this.max_x = this.x;
		if (this.y > this.max_y) this.max_y = this.y;
		if (this.x < this.min_x) this.min_x = this.x;
		if (this.y < this.min_y) this.min_y = this.y;
		this.ctx.lineTo( this.x, this.y );
		this.ctx.closePath(); 
		this.ctx.stroke(); 
		// console.debug( '...to '+this.x+','+this.y );
	},
	
	setColour: function( index ){
		this.colour = this.options.colours[ index ];
		this.ctx.strokeStyle =  this.colour;
	},
	
	resize: function(){
		console.log(this.min_x +'->'+ this.max_x);
		console.log(this.min_y +'->'+ this.max_y);
		var wi = Math.abs( this.min_x ) 
			+ Math.abs( this.max_x );
		var hi = Math.abs( this.min_y ) 
			+ Math.abs( this.max_y );
		console.log( this.canvas.width +','+ this.canvas.height);
		console.log( wi+','+hi );
		var sx = this.canvas.width / wi;
		var sy = this.canvas.height / hi;
		console.log('Scale: '+ sx+','+sy );
		this.canvas.width = this.canvas.width;
		
		this.ctx.scale( sx, sy );
		
		this.x 			= this.options.init_x || 0;
		this.y 			= this.options.init_y || this.options.canvas_height/2;
		this.y -=  this.min_y;

		console.log( this.y);
		this.render();
	}
});



